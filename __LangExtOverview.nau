
// Principles ‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾\ {{{1

	- keep chsheet in original hy (do not use my macroses)

	- functions are without special symbols in names,
	  macroses can contain special symbols

	Levels of modifications:
	- hy-idiomatic		-> keep
	- hy-ontheverge		-> in incubator until decided
	- ML syntax, etc.	-> keep as separate module, allow non-full hy integration (:: annotation, pointfree zone, etc.)
	- separate hghl for non-idiomatic macros?

	==============================================================================

	• .attr				is attr		// can't be passed as arg, use (get_attr ..)
	• (.method) 		is method	// can't be passed as arg
	  - (-> object .append) is allowed, but I will use (-> object (.append)) instead
	  - (mth> .sort)		is method, but passed instead of called 
	• (. object method) is object.method

	+ arguments order logic:
	  - (f params vrbl) // good for partial application and ->> macro
	  - (f vrbl params) // good for -> macro

// ____________________________________________________________________________/ }}}1

// Macroses ‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾\ {{{1

	@@ TODO: restric macroses imput, throw errors
	@@ TODO: => with .attr recognition as getattr

	• f::	(f:: int -> int -> (of Tuple int str))
	• L#	(rename of #% macro)	
	• fm 	(fm (* %1 2))
	• lns, l>, l>= &+, &+>			
	  - (lns 1 "dict" vrbl .attr)	// attr   can't be passed as arg, use (GetAttr  "attr")
	  - (mth> .sort)				// method can't be passed as arg, use (call     "mth" ..)
	  - (mut> .sort :shallow True)	// method can't be passed as arg, use (call_mut "mth" ..)
	  - (dndr>  / 1)				@@ todo later: add & recognition
	  - (dndr>> / 1)
	• pluckm						
	  - (pluckm 1 xs) 
	  - (pluckm "2" xs)
	  - (pluckm vrbl xs)
	  - (pluckm .x xs)				// attr   can't be passed as arg, use (pluck_attr "attr" ..)
	• p>	(p> abs (flip func a))	// pipe of partials @@ todo: (. ss), .attr recognition


    // (rcompose f1 f2)
    // (-> data  f1 f2)
    // (l> data   1  2)
    // (p> data  f1 f2)
    ; not required for p> :
    ; (. dpg (create 3)) -> use (dpg.create 3) instead


// ____________________________________________________________________________/ }}}1
// Macroses: pending ‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾\ {{{1

	+ (gat xs .attr)	// intended usage: with -> macros... or just include this feature in => macro?
	+ <- <<-
	+ => =>>
	+ <<= <=_

// ____________________________________________________________________________/ }}}1

	@@ todo: pass kwargs in p>
	@@ todo: doc
	! вместо Хаскель-синтаксиса, попытайся придумать эквивалентный Хай-синтаксис
	- который был бы идиоматичен и тоже макс удобен, и хотелось бы про который сказать:
	- «ну это уже выбор между Хай и Хаскелем, тут уже вопрос предпочтений», а не «как же криво оно всё сделано!»

	apply_n -> change syntax

// New Functions ‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾\ {{{1

	- fltr1st -> funcy.some
	- take_last

	- lreversed
	- lstarmap

	- split (at by f) -> more like sift, returns 2 lists
	  split_at (n)	  -> just one cut,   returns 2 lists
	  split_by (f)	  -> just one cut,   returns 2 lists
	  takewhile
	  dropwhile

	- none
	  one

	- merge
	  join
	  cat
	  
	- map
	  walk

	- without

	- count_by
	  count_reps
	  group_by
	  group_by_keys
	  group_values

// ____________________________________________________________________________/ }}}1

